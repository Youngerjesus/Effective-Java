## 아이템 6 - 불필요한 객체 생성을 피하라

***

똑같은 기능을 하는 객체가 있다면 이는 매번 만드는 것보다 재사용하는게 훨씬 낫다. 특히 그 객체가 불변 객체라면 말이다. 

다음은 절대 해서는 안되는 행동이다. 

```java
String s = new String("abc"); 
```

- 이 문장은 쓸데가 없는데 왜냐하면 생성자에 넘겨주는 "abc" 와 만들어지는 s 는 완전히 똑같은 객체지만 메모리를 더 써서 굳이 객체를
만들고 있기 때문이다. 

- 만약 이 문장이 반복문안에서 몇백번 반복되고 있다면 똑같은 기능을 하는 문자열이지만 매번 메모리에다가 객체를 만드는 일을 하고 있을 것이다. 

그러므로 앞으로 이렇게 하자.

```java
String s = "abc"; 
```

- 이 코드는 인스턴스를 매번 만드는게 아니라 하나의 String 풀에서 이것을 사용하는 문자열은 재사용하도록 해준다. 

셍성자 대신 정적 팩토리 메소드를 이용하면 매번 같은 객체를 생성해주는 걸 막아줄 수 있다. 

생성자는 매번 새로운 객체를 만들어주지만 정적 팩토리 메소드는 그렇지 않다. 

##### 불필요한 객체 생성을 막아주는 정적 팩토리 메소드 예시

```java
Boolean b = Boolean.valueOf(true)
``` 

그리고 애초에 객체 생성 비용이 큰 객체도 더러 있다. 이런 비싼 객체를 반복해서 생성하지 말고 할 수 있다면 캐싱해서 사용하는걸
권한다. 

예를들어 문자열이 유효한 로마 숫자인지 검사하는 메소드를 작성한다고 해보자. 

##### 로마 숫자 검사 메소드 - Bad Version

```java
static boolean isRomanNumeral(String s){
    return s.matches("^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\n");
}
```

- 이 방식의 문제는 String 메소드인 matches 를 호출하기 떄문이다. 

- matches 내부에는 Pattern 객체의 인스턴스를 만드는데 이 Pattern 객체는 유한 상태 머신(Finite State Machine) 으로 객체 생성 비용이 높다.
그리고 이 Pattern 객체는 한번 만들어지고 버려지므로 바로 가비지 컬렉션의 대상이 된다. 

그러므로 다음과 같이 만드는게 좋다.

##### 로마 숫자 검사 메소드 - Good Version

````java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile("^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\n"); 
    
    
    static boolean isRomanNumeralGoodVersion(String s){
        return ROMAN.matcher(s).matches(); 
    }
}
````
- 이렇게하면 ROMAN 객체를 재사용함으로써 성능을 상당히 끌어올릴 수 있다. 

- 이 방식의 단점이라면 RomanNumerals 메소드를 한번도 호출하지 않는다면 불 필요한 ROMAN 객체만 만든 꼴이다. 
이를 방지하기 위해서 Lazy Initializing 을 쓸 수 있는데 이를 정확하게 지키기에는 코드만 복잡해지지 성능은 그닥 좋아지지 않는다. 

겍체를 재사용할 때 불변성을 가진다면 재사용해도 명백히 좋다. 

그렇지만 불변하지 않더라도 객체를 재활용하는게 더 직관적이고 명확한 경우도 있다. 

Adapter 패턴을 생각해보자 어댑터 패턴은 객체와 객체를 연결해주는 제2 인터페이스와 같은 역할을 하며 뒷단에 있는 객체를 관리해주는 역할을 한다. 

예컨대 Map 인터페이스의 keySet 메소드는 Map 객체가 가진 모든 Key 를 리턴해주는 메소드다. 

keySet을 호출할 때마다 매번 새로운 Key 들이 나올것이라고 예상할 수 있겠지만 반환된 Key들은 가변적인 Key일 수 있다. 

즉 KeySet을 호출 한 후 Key를 바꾸면 Map이 영향을 받을 수 있다. 하지만 이런게 더 직관적이다. 매번 다른 객체를 반환하는겐
그럴 필요가 없다 사실. 

불필요한 객체를 만들어내는 또 다른 예로는 Wrapper 타입인 Auto Boxing이 있다.

의미상으로는 무슨 차이인지 모를 수 있지만 성능상으로는 그렇지 않다. 

다음과 같은 예를 보자. 

##### Auto Boxing 사용 예제 - 이렇게 하지말자.  

```java
public long sum(){
    Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE ; i++) {
        sum += i;
    }
    return sum;
}
```

- 이 메소드의 경우 long 이 아닌 Long 타입으로 선언해서 매번 i 값을 더할때마다 새로운 sum 이 만들어진다. 
단순히 Long 타입을 long 타입으로 바꿔주기만 해도 성능은 엄청나게 좋아진다. 

이 장읜 내용을 "객체 생성은 비싸니 피하자." 라고 생각하지는 말자. 

가비지 컬렉션의 경우에도 효율적으로 잘 작동하니 부담가지 않는다. 다만 불필요한 객체인 경우에 재사용 할 수 있으면 재사용하자. 라고 이해하면 되겠다. 

이번 장의 내용은 앞으로 나올 아이템 - 50 인 방어적 복사(defensive copy) 와는 대조적이다. 

방어적 복사에서는 "새로운 객체를 만들어야 한다면 기존의 객체를 재사용하지 말자" 이고 이번 장의 내용은 "기존 객체를
재사용 해야한다면 새로운 객체를 만들지 말자" 이다. 내용이 다르다.

 
   

